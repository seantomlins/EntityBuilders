using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EntityBuilders;

[Generator]
public class EntityBuilderGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var config = new EntityBuilderConfig(context);

        AddIdProviderSource(context, config);

        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        foreach (var classDeclarationSyntax in syntaxTree
                     .GetRoot()
                     .DescendantNodes()
                     .OfType<ClassDeclarationSyntax>()
                     .Where(x => x.AttributeLists.Any())
                     .ToImmutableList())
        foreach (var attribute in classDeclarationSyntax.AttributeLists.SelectMany(x => x.Attributes))
        {
            if (attribute.Name.ToString() == "GenerateEntityBuilder")
            {
                GenerateBuilder(context, classDeclarationSyntax, config);
            }
        }
    }

    private static void AddIdProviderSource(GeneratorExecutionContext context, EntityBuilderConfig config)
    {
        context.AddSource("IIdProvider.g.cs", SourceText.From(@$"// <auto-generated />
namespace {config.RootNamespace}
{{
    public interface IIdProvider
    {{
        int NewId();
    }}

    public class SequentialProvider : IIdProvider
    {{
        private int Count;

        public int NewId()
        {{
            return ++Count;
        }}
    }}
}}
", Encoding.UTF8));
    }

    private static void GenerateBuilder(GeneratorExecutionContext context,
        ClassDeclarationSyntax classDeclarationSyntax,
        EntityBuilderConfig config)
    {
        var typeNamespace = NamespaceParser.GetNamespace(classDeclarationSyntax);
        var className = classDeclarationSyntax.Identifier;
        var idPropertyName = IdPropertyParser.GetIdPropertyName(classDeclarationSyntax);
        var propertyMethods = GeneratePropertyMethods(classDeclarationSyntax, className);

        var sourceText = SourceText.From($@"// <auto-generated />
using {typeNamespace};

namespace {config.RootNamespace}
{{
    public partial class {className}Builder
    {{
        private readonly {className} _entity;

        public {className}Builder(IIdProvider idProvider)
        {{
            _entity = new {className}();
            this.{idPropertyName}(idProvider.NewId());
        }}

        public {className} Build()
        {{
            return _entity;
        }}

        #region Property Methods
        {propertyMethods}
        #endregion
    }}
}}
", Encoding.UTF8);

        context.AddSource($"{className}.g.cs", sourceText);
    }

    private static string GeneratePropertyMethods(ClassDeclarationSyntax classDeclarationSyntax, SyntaxToken className)
    {
        var properties = classDeclarationSyntax.Members
            .OfType<PropertyDeclarationSyntax>();

        var propertyMethods = string.Join(string.Empty, properties.Select(x => $@"
        public {className}Builder {x.Identifier}({x.Type} value){{
            _entity.{x.Identifier} = value;
            return this;
        }}
"));
        return propertyMethods;
    }

    // determine the namespace the class/enum/struct is declared in, if any
}